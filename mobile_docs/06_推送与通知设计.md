# 律时移动端 - 推送与通知设计

> **版本**: 1.0  
> **创建日期**: 2026-01-01

---

## 一、推送架构

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                       律时服务端                                  │
│  ┌───────────────────┐    ┌───────────────────┐                 │
│  │   Rust API        │───▶│  通知触发服务     │                 │
│  │ (事件触发)        │    │ (队列消费)        │                 │
│  └───────────────────┘    └─────────┬─────────┘                 │
│                                     │                            │
│                           ┌─────────▼─────────┐                 │
│                           │   推送网关        │                 │
│                           │ (统一分发)        │                 │
│                           └─────────┬─────────┘                 │
└─────────────────────────────────────┼───────────────────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              │                       │                       │
              ▼                       ▼                       ▼
┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐
│   Firebase Cloud    │ │   APNs (iOS)        │ │   WebSocket         │
│   Messaging (FCM)   │ │                     │ │   (在线推送)        │
│   - Android         │ │                     │ │                     │
│   - iOS (可选)      │ │                     │ │                     │
└─────────────────────┘ └─────────────────────┘ └─────────────────────┘
              │                       │                       │
              └───────────────────────┼───────────────────────┘
                                      │
                                      ▼
                        ┌─────────────────────┐
                        │   律时移动端        │
                        │   (Flutter App)     │
                        └─────────────────────┘
```

### 1.2 推送渠道

| 渠道 | 平台 | 优先场景 |
|------|------|----------|
| **FCM** | Android / iOS | 离线推送、后台推送 |
| **APNs** | iOS | 可选直连（FCM 已覆盖） |
| **WebSocket** | 全平台 | 在线时实时推送 |
| **本地通知** | 全平台 | 日程提醒、计时提醒 |

---

## 二、通知类型

### 2.1 通知分类

| 类型 | 描述 | 推送方式 | 声音/震动 |
|------|------|----------|-----------|
| **任务分配** | 有新任务指派给你 | FCM + In-App | ✅ |
| **审批请求** | 待你审批的事项 | FCM + In-App | ✅ |
| **审批结果** | 你的申请已审批 | FCM + In-App | ❌ |
| **日程提醒** | 日程即将开始 | Local + FCM | ✅ |
| **案件更新** | 案件状态变更 | In-App | ❌ |
| **消息** | 新聊天消息 | FCM + In-App | ✅ |
| **系统公告** | 系统维护通知 | FCM + In-App | ❌ |

### 2.2 通知数据模型

```dart
@freezed
class PushNotification with _$PushNotification {
  const factory PushNotification({
    required String id,
    required NotificationType type,
    required String title,
    required String body,
    Map<String, dynamic>? data,  // 跳转参数
    DateTime? scheduledAt,
    required DateTime createdAt,
    bool? read,
  }) = _PushNotification;
}

enum NotificationType {
  taskAssigned,
  approvalRequest,
  approvalResult,
  scheduleReminder,
  caseUpdate,
  chatMessage,
  systemAnnouncement,
}
```

---

## 三、Firebase 集成

### 3.1 依赖配置

```yaml
# pubspec.yaml
dependencies:
  firebase_core: ^2.24.2
  firebase_messaging: ^14.7.10
  flutter_local_notifications: ^16.3.0
```

### 3.2 初始化

```dart
// lib/core/services/notification_service.dart
class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final FlutterLocalNotificationsPlugin _localNotifications = 
      FlutterLocalNotificationsPlugin();
  
  Future<void> init() async {
    // 请求权限 (iOS)
    await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );
    
    // 获取 FCM Token
    final token = await _messaging.getToken();
    await _registerDeviceToken(token!);
    
    // 监听 Token 刷新
    _messaging.onTokenRefresh.listen(_registerDeviceToken);
    
    // 初始化本地通知
    await _initLocalNotifications();
    
    // 监听前台消息
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
    
    // 监听后台消息点击
    FirebaseMessaging.onMessageOpenedApp.listen(_handleNotificationTap);
    
    // 检查冷启动通知
    final initialMessage = await _messaging.getInitialMessage();
    if (initialMessage != null) {
      _handleNotificationTap(initialMessage);
    }
  }
  
  Future<void> _registerDeviceToken(String token) async {
    await GetIt.I<AuthApi>().registerDeviceToken(
      token: token,
      platform: Platform.isIOS ? 'ios' : 'android',
    );
  }
  
  Future<void> _initLocalNotifications() async {
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );
    
    await _localNotifications.initialize(
      InitializationSettings(android: androidSettings, iOS: iosSettings),
      onDidReceiveNotificationResponse: _onLocalNotificationTap,
    );
  }
}
```

### 3.3 前台消息处理

```dart
void _handleForegroundMessage(RemoteMessage message) {
  final notification = PushNotification.fromRemoteMessage(message);
  
  // 在应用内显示通知 Banner
  _showInAppNotification(notification);
  
  // 同时显示本地通知（用户可能在其他页面）
  _showLocalNotification(notification);
  
  // 更新通知中心未读数
  ref.read(unreadNotificationCountProvider.notifier).increment();
}

void _showInAppNotification(PushNotification notification) {
  // 使用 overlay 显示顶部 Banner
  OverlayEntry? overlay;
  overlay = OverlayEntry(
    builder: (context) => Positioned(
      top: MediaQuery.of(context).padding.top + 8,
      left: 16, right: 16,
      child: NotificationBanner(
        notification: notification,
        onTap: () {
          overlay?.remove();
          _navigateToDetail(notification);
        },
        onDismiss: () => overlay?.remove(),
      ),
    ),
  );
  
  Overlay.of(navigatorKey.currentContext!).insert(overlay);
  
  // 3秒后自动消失
  Future.delayed(Duration(seconds: 3), () => overlay?.remove());
}
```

### 3.4 通知点击处理

```dart
void _handleNotificationTap(RemoteMessage message) {
  final notification = PushNotification.fromRemoteMessage(message);
  _navigateToDetail(notification);
}

void _navigateToDetail(PushNotification notification) {
  final router = GetIt.I<GoRouter>();
  
  switch (notification.type) {
    case NotificationType.taskAssigned:
      router.push('/tasks/${notification.data?['taskId']}');
    case NotificationType.approvalRequest:
      router.push('/approvals/${notification.data?['approvalId']}');
    case NotificationType.scheduleReminder:
      router.push('/calendar?date=${notification.data?['date']}');
    case NotificationType.chatMessage:
      router.push('/chat/${notification.data?['channelId']}');
    case NotificationType.caseUpdate:
      router.push('/cases/${notification.data?['caseId']}');
    default:
      router.push('/notifications');
  }
}
```

---

## 四、本地通知（日程提醒）

### 4.1 日程提醒调度

```dart
class ScheduleReminderService {
  final FlutterLocalNotificationsPlugin _localNotifications;
  
  Future<void> scheduleEventReminder(CalendarEvent event) async {
    if (event.reminder == null) return;
    
    final reminderTime = event.startTime.subtract(
      Duration(minutes: event.reminder!.minutesBefore),
    );
    
    if (reminderTime.isBefore(DateTime.now())) return;
    
    await _localNotifications.zonedSchedule(
      event.id.hashCode,
      '日程提醒',
      '${event.title} 将在 ${event.reminder!.minutesBefore} 分钟后开始',
      tz.TZDateTime.from(reminderTime, tz.local),
      NotificationDetails(
        android: AndroidNotificationDetails(
          'schedule_reminders',
          '日程提醒',
          channelDescription: '日程开始前的提醒通知',
          importance: Importance.high,
          priority: Priority.high,
        ),
        iOS: DarwinNotificationDetails(
          presentAlert: true,
          presentBadge: true,
          presentSound: true,
        ),
      ),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.absoluteTime,
      payload: jsonEncode({
        'type': 'schedule_reminder',
        'eventId': event.id,
      }),
    );
  }
  
  Future<void> cancelEventReminder(String eventId) async {
    await _localNotifications.cancel(eventId.hashCode);
  }
}
```

### 4.2 计时提醒

```dart
class TimerReminderService {
  /// 计时超时提醒（例如：计时超过 4 小时）
  Future<void> scheduleTimerOverdueReminder(String timelogId, Duration threshold) async {
    await _localNotifications.zonedSchedule(
      'timer_overdue_$timelogId'.hashCode,
      '计时提醒',
      '当前计时已超过 ${threshold.inHours} 小时，请确认是否正常',
      tz.TZDateTime.now(tz.local).add(threshold),
      NotificationDetails(
        android: AndroidNotificationDetails(
          'timer_reminders',
          '计时提醒',
          importance: Importance.defaultImportance,
        ),
      ),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.absoluteTime,
    );
  }
}
```

---

## 五、通知中心

### 5.1 通知列表页

```dart
class NotificationsScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final notifications = ref.watch(notificationsProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: Text('通知中心'),
        actions: [
          TextButton(
            onPressed: () => ref.read(notificationsProvider.notifier).markAllRead(),
            child: Text('全部已读'),
          ),
        ],
      ),
      body: notifications.when(
        data: (list) => ListView.builder(
          itemCount: list.length,
          itemBuilder: (context, index) => NotificationListItem(
            notification: list[index],
            onTap: () {
              ref.read(notificationsProvider.notifier).markAsRead(list[index].id);
              _navigateToDetail(context, list[index]);
            },
          ),
        ),
        loading: () => Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('加载失败')),
      ),
    );
  }
}
```

### 5.2 通知列表项

```dart
class NotificationListItem extends StatelessWidget {
  final PushNotification notification;
  final VoidCallback onTap;
  
  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Container(
        padding: EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: notification.read == true 
            ? Colors.white 
            : LegalMindColors.primary50,
          border: Border(
            bottom: BorderSide(color: NeutralColors.neutral200),
          ),
        ),
        child: Row(
          children: [
            _buildIcon(),
            SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    notification.title,
                    style: TextStyle(
                      fontWeight: notification.read == true 
                        ? FontWeight.normal 
                        : FontWeight.w600,
                    ),
                  ),
                  SizedBox(height: 4),
                  Text(
                    notification.body,
                    style: TextStyle(
                      color: NeutralColors.neutral600,
                      fontSize: 14,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  SizedBox(height: 4),
                  Text(
                    _formatTime(notification.createdAt),
                    style: TextStyle(
                      color: NeutralColors.neutral500,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
            if (notification.read != true)
              Container(
                width: 8,
                height: 8,
                decoration: BoxDecoration(
                  color: LegalMindColors.primary500,
                  shape: BoxShape.circle,
                ),
              ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildIcon() {
    IconData icon;
    Color color;
    
    switch (notification.type) {
      case NotificationType.taskAssigned:
        icon = Icons.assignment;
        color = FunctionalColors.info;
      case NotificationType.approvalRequest:
        icon = Icons.pending_actions;
        color = FunctionalColors.warning;
      case NotificationType.chatMessage:
        icon = Icons.chat;
        color = FunctionalColors.success;
      default:
        icon = Icons.notifications;
        color = NeutralColors.neutral500;
    }
    
    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Icon(icon, color: color, size: 20),
    );
  }
}
```

---

## 六、通知偏好设置

### 6.1 设置页面

```dart
class NotificationSettingsScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(notificationSettingsProvider);
    
    return Scaffold(
      appBar: AppBar(title: Text('通知设置')),
      body: ListView(
        children: [
          _SectionHeader('推送通知'),
          SwitchListTile(
            title: Text('任务分配'),
            subtitle: Text('有新任务指派给你时通知'),
            value: settings.taskAssigned,
            onChanged: (v) => _updateSetting(ref, 'taskAssigned', v),
          ),
          SwitchListTile(
            title: Text('审批请求'),
            subtitle: Text('有待审批事项时通知'),
            value: settings.approvalRequest,
            onChanged: (v) => _updateSetting(ref, 'approvalRequest', v),
          ),
          SwitchListTile(
            title: Text('聊天消息'),
            subtitle: Text('收到新消息时通知'),
            value: settings.chatMessage,
            onChanged: (v) => _updateSetting(ref, 'chatMessage', v),
          ),
          SwitchListTile(
            title: Text('日程提醒'),
            subtitle: Text('日程开始前提醒'),
            value: settings.scheduleReminder,
            onChanged: (v) => _updateSetting(ref, 'scheduleReminder', v),
          ),
          _SectionHeader('免打扰'),
          SwitchListTile(
            title: Text('免打扰模式'),
            subtitle: Text('指定时间段内静默通知'),
            value: settings.dndEnabled,
            onChanged: (v) => _updateSetting(ref, 'dndEnabled', v),
          ),
          if (settings.dndEnabled)
            ListTile(
              title: Text('免打扰时段'),
              subtitle: Text('${settings.dndStart} - ${settings.dndEnd}'),
              onTap: () => _showDndTimePicker(context, ref),
            ),
        ],
      ),
    );
  }
}
```

---

## 七、服务端推送触发

### 7.1 Rust 推送服务（示例）

```rust
// 推送服务接口
pub struct PushService {
    fcm_client: FcmClient,
}

impl PushService {
    pub async fn send_notification(&self, user_id: &str, notification: &Notification) -> Result<()> {
        // 获取用户设备 Token
        let devices = self.get_user_devices(user_id).await?;
        
        for device in devices {
            let message = FcmMessage {
                token: device.token,
                notification: Some(FcmNotification {
                    title: notification.title.clone(),
                    body: notification.body.clone(),
                }),
                data: notification.data.clone(),
                android: Some(AndroidConfig {
                    priority: "high".to_string(),
                }),
                apns: Some(ApnsConfig {
                    headers: ApnsHeaders {
                        priority: "10".to_string(),
                    },
                }),
            };
            
            self.fcm_client.send(message).await?;
        }
        
        Ok(())
    }
}
```

### 7.2 推送触发点

| 事件 | 触发条件 | 通知接收人 |
|------|----------|------------|
| 任务创建 | 任务指派给某人 | 被指派人 |
| 审批提交 | 创建审批请求 | 审批人 |
| 审批完成 | 审批通过/拒绝 | 申请人 |
| 消息发送 | 发送聊天消息 | 频道成员（除发送者） |
| 案件状态变更 | 案件状态更新 | 案件团队成员 |

---

**文档完成**: 所有移动端设计文档已编写完毕
